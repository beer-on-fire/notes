# 整理的一些各种途径来的面试题 #

--------------


### Q1： 为何会出现浏览器兼容性问题？如何解决？
 
#### A1：
-	为何出现?
	-	同一产品，版本越老 bug 越多
	-	同一产品，版本越新，功能越多
	-	不同产品，不同标准，不同实现方式
-	如何解决？
	1. 要不要做
		-	产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）
		-	成本的角度 (有无必要做某件事)
	2. 做到什么程度
		-	让哪些浏览器支持哪些效果
	3. 如何做
		-	根据兼容需求选择技术框架（库/jq）
		-	根据兼容需求选择兼容工具（html5shiv.js、respond.js、css reset、normalize.css、Modernizr）
		-	postCss提供了一个解析器，它能够将 CSS 解析成抽象语法树。	
		-	条件注释、CSS Hack、js 能力检测做一些修补
	4. 两种方案
		-	渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验
		-	优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
		

### Q2: 重复声明两个函数会怎样？

#### A2: 重复申明两个函数跟重复生命两个变量本质上是一样的，都是以最后一次声明为准。

### Q3： 原型链、作用域链
- 案例一：
- 
    function Foo() {
	    getName = function () { 
	    	console.log('1');
	    };
	    return this;
    }
    Foo.getName = function () {
    	console.log('2');
    };
    Foo.prototype.getName = function () { 
    	console.log('3');
    };
    var getName = function () { 
    	console.log('4');
    };
    function getName() { 
    	console.log(5);
    }
    
    Foo.getName();  
    getName();	
    Foo().getName(); 
    getName();  
    new Foo.getName(); 
    new Foo().getName();   
    new new Foo().getName();		

#### A3：
###### JavaScript的操作符优先级,从高到低排序![](https://i.imgur.com/JHbKpqp.png)
###### 运算符优先级![](https://i.imgur.com/8ANDBE4.png)


	-	注意声明前置
    function Foo() {
    	//在函数内部声明的getName变量，前面是不带有var、let,const的，声明的getName是在全局范围内(也是就window)。也就是个全局变量
	    getName = function () {
	    	console.log('1');
	    };
	    return this;
    }
    // 为函数添加属性getName,其类型是Function，所以这里也可以看出来，Function也是一种Object
    Foo.getName = function () {
    console.log('2');
    };
    // 为Foo的原型添加方法getName
    Foo.prototype.getName = function () {
    console.log('3');
    };
    
    // var声明的变量和函数声明function都会被提升，但是函数声明的提升的级别是比var要高的
    
    var getName = function () {
    console.log('4');
    };
    function getName() {
    console.log(5);
    }
    
    Foo.getName();  // => 2 函数Foo本身并没有执行，执行的是函数的属性getName，当然输出的是：2.
    
    getName();	//   => 4在全局范围内执行了getName() ，，，实际顺序是 var getName | function getName(){} | getname = function(){}
    
    Foo().getName();  // =>  ()与.优先级相同，所以从左至右执行。首先运行Foo(), 全局 的getName被覆盖成输出console.log('1'),并且返回的this此时代表的是window。随后相当于执行的window.getName(),那么输出的实际就是1(被覆盖)。
    
    getName();   // => 1 同上
    
    new Foo.getName(); // =>2   . 操作符要比 new 优先级要高，所以实际执行的是new (Foo.getName)()
    
    new Foo().getName(); // =>3  首先看运算符优先级括号高于new。实际执行为(new Foo()).getName()。遂先执行Foo函数。new Foo()返回了新生成的对象，该对象没有getName()方法，所以在prototype中找到了getName()方法。所以输出的是3。 // 具体可看运算符优先级
    
    new new Foo().getName(); // => 3  第一步划分为：new (new Foo().getName)(); 第二步划分为：new ((new Foo()).getName)();
    

- 案例二：
-
    var a = 1;
    
    var a = 1;
    function fn(){
      console.log(a);//第一个输出值---->  undefined
      var a = 5;
      console.log(a);//第二个输出值---->  5  
      a++;
      var a;
      fn3();
      fn2();
      console.log(a);   //第五个输出值  ---->  20
    
      function fn2(){
    console.log(a); //第四个输出值  ---->   6
    a = 20;
      }
    }
    
    function fn3(){
      console.log(a)   //第三个输出值  ---->  1
      a = 200;
    }
    
    fn();
    console.log(a);   //第六个输出值---->  200
>  1、作用域在全局，调用全局变量 a，但由于函数内部变量重新声明，且根据变量声明提前但赋值不会提前，所以输出 undefined
2、作用域在函数 fn 内，调用 fn 内变量 a，此时函数内变量声明且赋值 var a = 5，所以输出为 5
3、作用域在全局，此时调用全局变量 a， 所以输出为 1
4、作用域在 fn 内，调用 fn 内变量 a，此时 fn 内由 a++ 计算后，a = 6，所以输出为 6
5、作用域在 fn 内，调用 fn 内变量 a，此时由于 fn2 函数执行，fn 内变量 a 重新赋值为 a = 20 ，所以输出为 20
6、作用域在全局，调用全局变量 a，此时由于 fn3 函数执行，全局变量 a 重新赋值为 a = 200 ，所以输出为 200

###  Q4:js等号及隐式类型转换等
    console.log( +0 ==  -0 ) // =>true
    
    console.log( +0 === -0 ) // => true
    
    console.log( Object.is(+0, -0) ) // => false   // Object.is()方法确定两个值是否相同。
    
    console.log( "1" == 1 ) // => true
    
    console.log( "1" === 1 ) // => false
    
    console.log( Object.is("1", 1) ) // => false
    
    console.log( new String("foo") == new String("foo") )  //   => false
    
    console.log( new String("foo") === new String("foo") ) // => false
    
    console.log( Object.is(new String("foo") , new String("foo") ) ) // => false
    
    console.log( new String("foo") == "foo" ) // => true
    console.log( new String("foo") === "foo" ) // => false
    console.log( Object.is(new String("foo") , "foo" ) ) // => false
    
    const a = {}
    const b = a
    console.log( a == b  ) // => true
    console.log( a === b  ) // => true
    console.log( Object.is(a, b) ) // => true

    console.log( NaN == NaN ) // => false
    console.log( NaN === NaN ) // => false
    console.log( Object.is(NaN, NaN) ) // => true

#### A4:
可参考![](https://i.imgur.com/oMfY5zJ.png)

### Q5:如何取得页面用到哪几种标签？
#### A5:
-	`document.all`能取得当前页面所有的`element`，判断`nodeType===1`就是`element`了，取`nodeName`就是标签名称，遍历做个类别统计就可以
-	`document.getElementsByTagName('*')`， 类似的还有jq`$("*")`

### Q6： 递归拆分
-	写一个函数，列出一个整数所有的分解类型，比如对于数字4，可以做拆分得到下列字符串1111|112|121|13|211|22|31|4
#### A6: 
-	`Array.from() `方法从一个类似数组或可迭代的对象中创建一个新的数组实例。
-
    function f() {
	    // Array.from() 方法从一个类似数组或可迭代的对象中创建一个新的数组实例。
	    var arr = Array.from(arguments);
	    // console.log(arr);
	    let before = arr.slice(0, arr.length - 1);
	    // console.log(before);
	    let n = arr[arr.length - 1];
	    // console.log(n);
	    for (let i = 1; i < n; i++) {
	    f(...before, i, n - i);
	    }
	    console.log(arr);
    }


### Q7: this指向
#### A7: 
-	this绑定有四种情况；
	-	默认绑定：函数独立调用时，this默认绑定到window
	-	隐式绑定：看函数调用栈，上一个的栈点就是this，console.trace()可查看函数的调用关系
	-	显式绑定：如call,apply,bind，this指向绑定对象
	-	new绑定：this指向new出来的对象

### Q8: 从 URL 输入到页面展现发生了什么?
#### A8： [http://blog.csdn.net/tangxiaolang101/article/details/54670218](http://blog.csdn.net/tangxiaolang101/article/details/54670218)

### Q9： 如何居中一个浮动元素？
#### A9： 
-	父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对右移动50%，或者子元素相对左移动-50%也就可以了
![](https://i.imgur.com/H12yAIB.png)	

### Q10: 前端路由实现方式?
#### A10: 两种实现前端路由的方式
-	hash就是url 中看到 # ,我们需要一个根据监听哈希变化触发的事件( hashchange) 事件。我们用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。
 可以为hash的改变添加监听事件：
```
window.addEventListener("hashchange", funcRef, false)
```
-	HTML5 History两个新增的API：history.pushState 和 history.replaceState，两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。

- 优点

> 从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，没有了网络延迟，对于用户体验来说会有相当大的提升。
> 前端路由的优点有很多，比如页面持久性，像大部分音乐网站，你都可以在播放歌曲的同时，跳转到别的页面而音乐没有中断，再比如前后端彻底分离。
开发一个前端路由，主要考虑到页面的可插拔、页面的生命周期、内存管理等。

- 缺点

>使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。

History interface提供了两个新的方法：`pushState()`, `replaceState()`使得我们可以对浏览器历史记录栈进行修改：
```
window.history.pushState(stateObject, title, URL)
window.history.replaceState(stateObject, title, URL)
```

### 闭包

特性：

	1. 函数嵌套函数
	2. 函数内部可以引用外部的参数和变量
	3. 参数和变量不会被垃圾回收机制回收

-	闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。

-	为什么要使用闭包：
	-	为了设计私有方法和变量，避免全局变量污染
	-	希望一个变量长期驻扎在内存中

### 什么是原型链

> 当从一个对象那里调取属性或方法时，如果该对象自身不存在这样的属性或方法，就会去自己关联的`prototype`对象那里寻找，如果prototype没有，就会去prototype关联的前辈prototype那里寻找，如果再没有则继续查找`Prototype.Prototype`引用的对象，依次类推，直到Prototype.….Prototype为undefined（Object的Prototype就是undefined）从而形成了所谓的“原型链”。其中foo是Function对象的实例。而Function的原型对象同时又是Object的实例。这样就构成了一条原型链。


### ES6相关
#### 谈一谈let与var和const的区别？

- let为ES6新添加申明变量的命令，它类似于var，但是有以下不同：
	- let命令不存在变量提升，如果在let前使用，会导致报错
	- 暂时性死区的本质，其实还是块级作用域必须“先声明后使用”的性质。
	- let，const和class声明的全局变量不是全局对象的属性。

-	const声明的变量与let声明的变量类似，它们的不同之处在于，const声明的变量只可以在声明时赋值，不可随意修改，否则会导致SyntaxError（语法错误）。

-	const只是保证变量名指向的地址不变，并不保证该地址的数据不变。const可以在多个模块间共享
-	let 暂时性死区的原因：var 会变量提升，let 不会。

#### 箭头函数

> 箭头函数不属于普通的 function，所以没有独立的上下文。箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
由于箭头函数没有自己的this，函数对象中的call、apply、bind三个方法，无法"覆盖"箭头函数中的this值。
箭头函数没有原本(传统)的函数有的隐藏arguments对象。
箭头函数不能当作generators使用，使用yield会产生错误。

在以下场景中不要使用箭头函数去定义：

- 定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。
- 箭头函数里不但没有 this，也没有 arguments, super ……

### 说说你对作用域链的理解

> 作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。

### fetch和Ajax有什么不同

-	`XMLHttpRequest` 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，`generator/yield`，`async/await` 友好。

-	fetch 是浏览器提供的一个新的 web API，它用来代替 Ajax（XMLHttpRequest），其提供了更优雅的接口，更灵活强大的功能。
Fetch 优点主要有：

	- 语法简洁，更加语义化
	- 基于标准 Promise 实现，支持 `async/await`
	- fetch()返回的promise将不会拒绝http的错误状态，即使响应是一个HTTP 404或者500 
	- 在默认情况下 fetch不会接受或者发送cookies
	
-	使用fetch开发项目的时候的问题：

	1、所有的IE浏览器都不会支持 fetch()方法
	2、服务器端返回 状态码 400 500的时候 不会reject

### Cookie相关

> 如果想让cookie存在一段时间，就要为expires属性设置为未来的一个用毫秒数表示的过期日期或时间点，expires默认为设置的expires的当前时间。现在已经被max-age属性所取代，max-age用秒来设置cookie的生存期。如果max-age为0，则表示删除该cookie。

cookie的属性：

- HttpOnly属性告之浏览器该 cookie 绝不能通过 JavaScript 的 `document.cookie` 属性访问。
- domain属性可以使多个web服务器共享cookie。
- 只有path属性匹配向服务器发送的路径，Cookie 才会发送。必须是绝对路径
- secure属性用来指定Cookie只能在加密协议HTTPS下发送到服务器。
- max-age属性用来指定Cookie有效期
- expires属性用于指定Cookie过期时间。它的格式采用Date.toUTCString()的格式。

浏览器的同源政策规定，两个网址只要域名相同和端口相同，就可以共享Cookie。

### GET,POST,PUT,Delete

1. GET请求会向数据库获取信息，只是用来查询数据，不会修改，增加数据。使用URL传递参数，对所发送的数量有限制，一般在2000字符
2. POST向服务器发送数据，会改变数据的种类等资源，就像insert操作一样，会创建新的内容，大小一般没有限制，POST安全性高，POST不会被缓存
3. PUT请求就像数据库的update操作一样，用来修改数据内容，不会增加数据种类
4. Delete用来删除操作

#### GET和POST的区别

1. GET使用URL或Cookie传参，而POST将数据放在BODY中，这个是因为HTTP协议用法的约定。并非它们的本身区别。
2. GET方式提交的数据有长度限制，则POST的数据则可以非常大，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。也不是GET和POST本身的区别。
3. POST比GET安全，因为数据在地址栏上不可见，这个说法没毛病，但依然不是GET和POST本身的区别。

GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。（幂等性：对同一URL的多个请求应该返回同样的结果。）因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用

###  ajax请求和原理

    var xhr = new XMLHTTPRequest();
    // 请求 method 和 URI
    xhr.open('GET', url);
    // 请求内容
    xhr.send();
    // 响应状态
    xhr.status
    // xhr 对象的事件响应
    xhr.onreadystatechange = function() {}
    xhr.readyState
    // 响应内容
    xhr.responseText
- AJAX的工作原理

> Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。　Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。

- ajax优缺点

	-	优点：
		
		1）无刷新更新数据
		2）异步与服务器通信
		3）前后端负载均衡

	-	缺点：

		1）ajax干掉了Back和history功能，对浏览器机制的破坏
		2）对搜索引擎支持较弱
		3）违背了URI和资源定位的初衷

### 有哪些多屏适配方案

- media query + rem
- flex
- 弹性布局
- flexiable 整体缩放（动态设置缩放系数的方式，
让layout viewport与设计图对应，极大地方便了重构，同时也避免了1px的问题）


### 从输入URL到页面展现，发生了什么（HTTP请求的过程）

HTTP是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。

1.域名解析，查找缓存
- 查找浏览器缓存（DNS缓存）
- 查找操作系统缓存（如果浏览器缓存没有，浏览器会从hosts文件查找是否有DNS信息）
- 查找路由器缓存
- 查找ISP缓存

2.浏览器获得对应的ip地址后，浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。
3.TCP/IP连接建立起来后，浏览器就可以向服务器发送HTTP请求
4.服务器处理请求，返回资源（MVC设计模式）
5.浏览器处理（加载，解析，渲染）
  - HTML页面加载顺序从上而下
  - 解析文档为有意义的结构，DOM树；解析css文件为样式表对象
  - 渲染。将DOM树进行可视化表示

6.绘制网页
  - 浏览器根据HTML和CSS计算得到渲染数，最终绘制到屏幕上

一个完整HTTP请求的过程为：
DNS Resolving -> TCP handshake -> HTTP Request -> Server -> HTTP Response -> TCP shutdown


### 缓存，存储相关（cookie，web storage和session）

cookie优点：
1.可以解决HTTP无状态的问题，与服务器进行交互
缺点：
1.数量和长度限制，每个域名最多20条，每个cookie长度不能超过4kb
2.安全性问题。容易被人拦截
3.浪费带宽，每次请求新页面，cookie都会被发送过去

#### cookie和session区别

1.cookie数据存放在客户的浏览器上，session数据放在服务器上。
2.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。

sessionStorage是当前对话的缓存，浏览器窗口关闭即消失，localStorage持久存在，除非清除浏览器缓存。

#### 页面缓存原理

页面缓存状态是由http header决定的，一个浏览器请求信息，一个是服务器响应信息。主要包括Pragma: no-cache、Cache-Control、 Expires、 Last-Modified、If-Modified-Since。

### Promise
> 所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。
> 
-	（1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。
-	（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。
	
-	有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。
-	缺点： 无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

### 谈谈Nodejs优缺点

>优点：

1. 事件驱动，异步编程，占用内存少
2. npm设计得好

>缺点：

1. Debug 很困难。没有 stack trace，出了问题很难查找问题的原因；
2. 如果设计不好，很容易让代码充满 callback，代码不优雅；
3. 可靠性低；
4. 单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。

### 谈谈你对组件的看法

一个组件应该有以下特征：

- 可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有（own）它创建的子组件，通过这个特性，一个复杂的 UI 可以拆分成多个简单的 UI 组件；
- 可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个 UI 场景；
- 可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护；
- 可测试（Testable）：因为每个组件都是独立的，那么对于各个组件分别测试显然要比对于整个 UI 进行测试容易的多。