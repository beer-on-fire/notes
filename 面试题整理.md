# 整理的一些各种途径来的面试题 #

--------------


### Q1： 为何会出现浏览器兼容性问题？如何解决？
 
#### A1：
-	为何出现?
	-	同一产品，版本越老 bug 越多
	-	同一产品，版本越新，功能越多
	-	不同产品，不同标准，不同实现方式
-	如何解决？
	1. 要不要做
		-	产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）
		-	成本的角度 (有无必要做某件事)
	2. 做到什么程度
		-	让哪些浏览器支持哪些效果
	3. 如何做
		-	根据兼容需求选择技术框架（库/jq）
		-	根据兼容需求选择兼容工具（html5shiv.js、respond.js、css reset、normalize.css、Modernizr）
		-	postCss提供了一个解析器，它能够将 CSS 解析成抽象语法树。	
		-	条件注释、CSS Hack、js 能力检测做一些修补
	4. 两种方案
		-	渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验
		-	优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
		

### Q2: 重复声明两个函数会怎样？

#### A2: 重复申明两个函数跟重复生命两个变量本质上是一样的，都是以最后一次声明为准。

### Q3： 原型链、作用域链
- 案例一：
- 
    function Foo() {
	    getName = function () { 
	    	console.log('1');
	    };
	    return this;
    }
    Foo.getName = function () {
    	console.log('2');
    };
    Foo.prototype.getName = function () { 
    	console.log('3');
    };
    var getName = function () { 
    	console.log('4');
    };
    function getName() { 
    	console.log(5);
    }
    
    Foo.getName();  
    getName();	
    Foo().getName(); 
    getName();  
    new Foo.getName(); 
    new Foo().getName();   
    new new Foo().getName();		

#### A3：
###### JavaScript的操作符优先级,从高到低排序![](https://i.imgur.com/JHbKpqp.png)
###### 运算符优先级![](https://i.imgur.com/8ANDBE4.png)


	-	注意声明前置
    function Foo() {
    	//在函数内部声明的getName变量，前面是不带有var、let,const的，声明的getName是在全局范围内(也是就window)。也就是个全局变量
	    getName = function () {
	    	console.log('1');
	    };
	    return this;
    }
    // 为函数添加属性getName,其类型是Function，所以这里也可以看出来，Function也是一种Object
    Foo.getName = function () {
    console.log('2');
    };
    // 为Foo的原型添加方法getName
    Foo.prototype.getName = function () {
    console.log('3');
    };
    
    // var声明的变量和函数声明function都会被提升，但是函数声明的提升的级别是比var要高的
    
    var getName = function () {
    console.log('4');
    };
    function getName() {
    console.log(5);
    }
    
    Foo.getName();  // => 2 函数Foo本身并没有执行，执行的是函数的属性getName，当然输出的是：2.
    
    getName();	//   => 4在全局范围内执行了getName() ，，，实际顺序是 var getName | function getName(){} | getname = function(){}
    
    Foo().getName();  // =>  ()与.优先级相同，所以从左至右执行。首先运行Foo(), 全局 的getName被覆盖成输出console.log('1'),并且返回的this此时代表的是window。随后相当于执行的window.getName(),那么输出的实际就是1(被覆盖)。
    
    getName();   // => 1 同上
    
    new Foo.getName(); // =>2   . 操作符要比 new 优先级要高，所以实际执行的是new (Foo.getName)()
    
    new Foo().getName(); // =>3  首先看运算符优先级括号高于new。实际执行为(new Foo()).getName()。遂先执行Foo函数。new Foo()返回了新生成的对象，该对象没有getName()方法，所以在prototype中找到了getName()方法。所以输出的是3。 // 具体可看运算符优先级
    
    new new Foo().getName(); // => 3  第一步划分为：new (new Foo().getName)(); 第二步划分为：new ((new Foo()).getName)();
    

- 案例二：
-
    var a = 1;
    
    var a = 1;
    function fn(){
      console.log(a);//第一个输出值---->  undefined
      var a = 5;
      console.log(a);//第二个输出值---->  5  
      a++;
      var a;
      fn3();
      fn2();
      console.log(a);   //第五个输出值  ---->  20
    
      function fn2(){
    console.log(a); //第四个输出值  ---->   6
    a = 20;
      }
    }
    
    function fn3(){
      console.log(a)   //第三个输出值  ---->  1
      a = 200;
    }
    
    fn();
    console.log(a);   //第六个输出值---->  200
>  1、作用域在全局，调用全局变量 a，但由于函数内部变量重新声明，且根据变量声明提前但赋值不会提前，所以输出 undefined
2、作用域在函数 fn 内，调用 fn 内变量 a，此时函数内变量声明且赋值 var a = 5，所以输出为 5
3、作用域在全局，此时调用全局变量 a， 所以输出为 1
4、作用域在 fn 内，调用 fn 内变量 a，此时 fn 内由 a++ 计算后，a = 6，所以输出为 6
5、作用域在 fn 内，调用 fn 内变量 a，此时由于 fn2 函数执行，fn 内变量 a 重新赋值为 a = 20 ，所以输出为 20
6、作用域在全局，调用全局变量 a，此时由于 fn3 函数执行，全局变量 a 重新赋值为 a = 200 ，所以输出为 200

###  Q4:js等号及隐式类型转换等
    console.log( +0 ==  -0 ) // =>true
    
    console.log( +0 === -0 ) // => true
    
    console.log( Object.is(+0, -0) ) // => false   // Object.is()方法确定两个值是否相同。
    
    console.log( "1" == 1 ) // => true
    
    console.log( "1" === 1 ) // => false
    
    console.log( Object.is("1", 1) ) // => false
    
    console.log( new String("foo") == new String("foo") )  //   => false
    
    console.log( new String("foo") === new String("foo") ) // => false
    
    console.log( Object.is(new String("foo") , new String("foo") ) ) // => false
    
    console.log( new String("foo") == "foo" ) // => true
    console.log( new String("foo") === "foo" ) // => false
    console.log( Object.is(new String("foo") , "foo" ) ) // => false
    
    const a = {}
    const b = a
    console.log( a == b  ) // => true
    console.log( a === b  ) // => true
    console.log( Object.is(a, b) ) // => true

    console.log( NaN == NaN ) // => false
    console.log( NaN === NaN ) // => false
    console.log( Object.is(NaN, NaN) ) // => true

#### A4:
可参考![](https://i.imgur.com/oMfY5zJ.png)

### Q5:如何取得页面用到哪几种标签？
#### A5:
-	`document.all`能取得当前页面所有的`element`，判断`nodeType===1`就是`element`了，取`nodeName`就是标签名称，遍历做个类别统计就可以
-	`document.getElementsByTagName('*')`， 类似的还有jq`$("*")`

### Q6： 递归拆分
-	写一个函数，列出一个整数所有的分解类型，比如对于数字4，可以做拆分得到下列字符串1111|112|121|13|211|22|31|4
#### A6: 
-	`Array.from() `方法从一个类似数组或可迭代的对象中创建一个新的数组实例。
-
    function f() {
	    // Array.from() 方法从一个类似数组或可迭代的对象中创建一个新的数组实例。
	    var arr = Array.from(arguments);
	    // console.log(arr);
	    let before = arr.slice(0, arr.length - 1);
	    // console.log(before);
	    let n = arr[arr.length - 1];
	    // console.log(n);
	    for (let i = 1; i < n; i++) {
	    f(...before, i, n - i);
	    }
	    console.log(arr);
    }

### Q7: this指向
#### A7: 
-	this绑定有四种情况；
	-	默认绑定：函数独立调用时，this默认绑定到window
	-	隐式绑定：看函数调用栈，上一个的栈点就是this，console.trace()可查看函数的调用关系
	-	显式绑定：如call,apply,bind，this指向绑定对象
	-	new绑定：this指向new出来的对象

### Q8: 从 URL 输入到页面展现发生了什么?
#### A8： [http://blog.csdn.net/tangxiaolang101/article/details/54670218](http://blog.csdn.net/tangxiaolang101/article/details/54670218)